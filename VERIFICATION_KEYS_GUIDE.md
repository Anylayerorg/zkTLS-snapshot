# TLSNotary Verification Keys Guide

Complete guide for generating, storing, and managing TLSNotary circuit verification keys.

## Overview

Verification keys (vkeys) are public parameters used to verify SNARK proofs generated by TLSNotary. They are specific to the TLSNotary circuit and must match between proof generation and verification.

**Key Points**:
- ✅ Public parameters (safe to share)
- ✅ Circuit-specific (must match TLSNotary circuit version)
- ✅ Required for proof verification
- ✅ Can be loaded from CDN or bundled

---

## Option 1: Download Pre-Generated Keys (Recommended)

### From TLSNotary Releases

The TLSNotary team provides pre-generated verification keys with each release:

```bash
# Download latest verification key
curl -L -o tlsnotary.vkey.json \
  https://github.com/tlsnotary/tlsn/releases/download/v0.1.0/tlsnotary.vkey.json

# Verify download
cat tlsnotary.vkey.json | jq '.protocol'  # Should show "groth16"
```

### From tlsn-js Package

If using `tlsn-js`, verification keys may be bundled:

```bash
# Check if bundled in package
ls node_modules/tlsn-js/dist/*.vkey.json

# Copy to project
cp node_modules/tlsn-js/dist/tlsnotary.vkey.json ./public/vkeys/
```

### Verification Key Structure

```json
{
  "protocol": "groth16",
  "curve": "bn128",
  "nPublic": 4,
  "vk_alpha_1": [...],
  "vk_beta_2": [...],
  "vk_gamma_2": [...],
  "vk_delta_2": [...],
  "vk_alphabeta_12": [...],
  "IC": [...]
}
```

---

## Option 2: Generate from Circuit (Advanced)

If you need to generate verification keys from the TLSNotary circuit:

### Prerequisites

- Rust installed
- `snarkjs` installed: `npm install -g snarkjs`
- TLSNotary circuit source code

### Step 1: Compile Circuit

```bash
# Clone TLSNotary repository
git clone https://github.com/tlsnotary/tlsn.git
cd tlsn

# Build circuit (if needed)
# Follow TLSNotary build instructions
```

### Step 2: Generate Trusted Setup

```bash
# Generate proving key and verification key
# This requires a trusted setup ceremony
snarkjs powersoftau new bn128 14 pot14_0000.ptau -v

# Contribute to ceremony (repeat multiple times)
snarkjs powersoftau contribute pot14_0000.ptau pot14_0001.ptau --name="First contribution" -v

# Prepare phase 2
snarkjs powersoftau prepare phase2 pot14_0001.ptau pot14_final.ptau -v

# Generate circuit-specific keys
snarkjs zkey new tlsnotary.r1cs pot14_final.ptau tlsnotary_0000.zkey

# Contribute to zkey (repeat)
snarkjs zkey contribute tlsnotary_0000.zkey tlsnotary_0001.zkey --name="First zkey contribution" -v

# Export verification key
snarkjs zkey export verificationkey tlsnotary_0001.zkey tlsnotary.vkey.json
```

**Note**: For production, use a trusted setup ceremony with multiple participants.

---

## Storage Options

### Option A: CDN (Recommended for Production)

**Pros**:
- ✅ Fast global access
- ✅ Easy updates
- ✅ No bundling overhead
- ✅ Version control via URL

**Cons**:
- ⚠️ Requires CDN setup
- ⚠️ Network dependency

#### Setup Steps

1. **Upload to CDN**:

```bash
# AWS S3 example
aws s3 cp tlsnotary.vkey.json s3://cdn.anylayer.com/vkeys/tlsnotary.vkey.json \
  --content-type "application/json" \
  --cache-control "public, max-age=31536000"

# Cloudflare R2 example
r2 put vkeys/tlsnotary.vkey.json tlsnotary.vkey.json \
  --content-type "application/json" \
  --cache-control "public, max-age=31536000"

# Google Cloud Storage example
gsutil cp tlsnotary.vkey.json gs://cdn.anylayer.com/vkeys/tlsnotary.vkey.json \
  -h "Content-Type:application/json" \
  -h "Cache-Control:public, max-age=31536000"
```

2. **Configure CDN URL**:

```bash
# Environment variable
export TLSNOTARY_VKEY_URL=https://cdn.anylayer.com/vkeys/tlsnotary.vkey.json

# Or in code
const vkeyUrl = process.env.TLSNOTARY_VKEY_URL || 
  'https://cdn.anylayer.com/vkeys/tlsnotary.vkey.json';
```

3. **Load in Code**:

```typescript
async function loadVerificationKey(): Promise<any> {
  const vkeyUrl = process.env.TLSNOTARY_VKEY_URL || 
    'https://cdn.anylayer.com/vkeys/tlsnotary.vkey.json';
  
  const response = await fetch(vkeyUrl);
  if (!response.ok) {
    throw new Error(`Failed to load verification key: ${response.statusText}`);
  }
  
  return await response.json();
}
```

### Option B: Bundle with Application

**Pros**:
- ✅ No network dependency
- ✅ Works offline
- ✅ Faster initial load

**Cons**:
- ⚠️ Increases bundle size (~50-100KB)
- ⚠️ Requires rebuild to update

#### Setup Steps

1. **Copy to assets**:

```bash
mkdir -p packages/zktls-extension/src/assets/vkeys
cp tlsnotary.vkey.json packages/zktls-extension/src/assets/vkeys/
```

2. **Load in Code**:

```typescript
// Extension
import tlsnotaryVkey from '../assets/vkeys/tlsnotary.vkey.json';

// Or dynamic import
const vkey = await import('../assets/vkeys/tlsnotary.vkey.json');
```

3. **Configure Webpack**:

```javascript
// webpack.config.js
module.exports = {
  // ... other config
  module: {
    rules: [
      {
        test: /\.json$/,
        type: 'asset/resource',
      },
    ],
  },
};
```

### Option C: Environment Variable (Backend)

**Pros**:
- ✅ Easy configuration
- ✅ Per-environment keys
- ✅ No CDN dependency

**Cons**:
- ⚠️ Requires environment setup
- ⚠️ Not suitable for client-side

#### Setup Steps

1. **Store key in environment**:

```bash
# Base64 encode (for single-line storage)
cat tlsnotary.vkey.json | base64 > tlsnotary.vkey.b64

# Or store as JSON string
export TLSNOTARY_VKEY=$(cat tlsnotary.vkey.json | jq -c .)
```

2. **Load in Code**:

```javascript
// Backend (Node.js)
function loadVerificationKey() {
  // From base64
  const vkeyBase64 = process.env.TLSNOTARY_VKEY_B64;
  if (vkeyBase64) {
    return JSON.parse(Buffer.from(vkeyBase64, 'base64').toString());
  }
  
  // From JSON string
  const vkeyJson = process.env.TLSNOTARY_VKEY;
  if (vkeyJson) {
    return JSON.parse(vkeyJson);
  }
  
  // Fallback to file
  return require('./tlsnotary.vkey.json');
}
```

### Option D: Secret Manager (Production Backend)

**Pros**:
- ✅ Secure storage
- ✅ Version control
- ✅ Access control

**Cons**:
- ⚠️ Requires cloud provider setup
- ⚠️ Additional API calls

#### AWS Secrets Manager

```bash
# Store key
aws secretsmanager create-secret \
  --name tlsnotary-vkey \
  --secret-string file://tlsnotary.vkey.json

# Or update existing
aws secretsmanager put-secret-value \
  --secret-id tlsnotary-vkey \
  --secret-string file://tlsnotary.vkey.json
```

```javascript
// Load in code
const AWS = require('aws-sdk');
const secretsManager = new AWS.SecretsManager();

async function loadVerificationKey() {
  const secret = await secretsManager.getSecretValue({
    SecretId: 'tlsnotary-vkey'
  }).promise();
  
  return JSON.parse(secret.SecretString);
}
```

#### Google Secret Manager

```bash
# Store key
gcloud secrets create tlsnotary-vkey --data-file=tlsnotary.vkey.json

# Grant access
gcloud secrets add-iam-policy-binding tlsnotary-vkey \
  --member="serviceAccount:your-service@project.iam.gserviceaccount.com" \
  --role="roles/secretmanager.secretAccessor"
```

```javascript
// Load in code
const {SecretManagerServiceClient} = require('@google-cloud/secret-manager');
const client = new SecretManagerServiceClient();

async function loadVerificationKey() {
  const [version] = await client.accessSecretVersion({
    name: 'projects/your-project/secrets/tlsnotary-vkey/versions/latest',
  });
  
  return JSON.parse(version.payload.data.toString());
}
```

---

## Implementation

### Extension (Client-Side)

**File**: `packages/zktls-extension/src/services/tlsnotary.ts`

```typescript
// Cache verification key
let cachedVkey: any = null;

async function getVerificationKey(): Promise<any> {
  if (cachedVkey) return cachedVkey;
  
  try {
    // Try CDN first
    const vkeyUrl = process.env.TLSNOTARY_VKEY_URL || 
      'https://cdn.anylayer.com/vkeys/tlsnotary.vkey.json';
    const response = await fetch(vkeyUrl);
    cachedVkey = await response.json();
    return cachedVkey;
  } catch (error) {
    console.warn('[TLSNotary] Failed to load vkey from CDN, using bundled version');
    
    // Fallback to bundled version
    const bundledVkey = await import('../assets/tlsnotary.vkey.json');
    cachedVkey = bundledVkey.default;
    return cachedVkey;
  }
}
```

### Backend (Firebase Functions)

**File**: `functions/src/services/zkTLSService.js`

```javascript
// Cache verification key
let cachedVkey = null;

async function loadVerificationKey() {
  if (cachedVkey) return cachedVkey;
  
  try {
    // Try CDN first
    const vkeyUrl = process.env.TLSNOTARY_VKEY_URL || 
      'https://cdn.anylayer.com/vkeys/tlsnotary.vkey.json';
    const response = await fetch(vkeyUrl);
    cachedVkey = await response.json();
    return cachedVkey;
  } catch (error) {
    console.error('[zkTLSService] Failed to load vkey:', error);
    throw new Error('Verification key not available');
  }
}
```

### Dashboard (Client-Side)

**File**: `dashboard-v2/src/services/verification.ts`

```typescript
// Cache verification key
let cachedVkey: any = null;

export async function getVerificationKey(): Promise<any> {
  if (cachedVkey) return cachedVkey;
  
  const vkeyUrl = process.env.NEXT_PUBLIC_TLSNOTARY_VKEY_URL || 
    'https://cdn.anylayer.com/vkeys/tlsnotary.vkey.json';
  
  const response = await fetch(vkeyUrl);
  if (!response.ok) {
    throw new Error(`Failed to load verification key: ${response.statusText}`);
  }
  
  cachedVkey = await response.json();
  return cachedVkey;
}
```

---

## Version Management

### Multiple Versions

If verification keys need to be rotated:

1. **Store multiple versions**:
   ```
   vkeys/
     tlsnotary.v1.vkey.json
     tlsnotary.v2.vkey.json
     tlsnotary.latest.vkey.json -> tlsnotary.v2.vkey.json
   ```

2. **Include version in proof**:
   ```typescript
   const proof = {
     // ... proof data
     circuitVersion: 'v2',  // Indicates which vkey to use
   };
   ```

3. **Load by version**:
   ```typescript
   async function loadVerificationKey(version: string = 'latest') {
     const vkeyUrl = `https://cdn.anylayer.com/vkeys/tlsnotary.${version}.vkey.json`;
     // ... load logic
   }
   ```

### Key Rotation

When rotating verification keys:

1. **Deploy new key** to CDN
2. **Update URL** in environment/config
3. **Deploy code** that uses new key
4. **Keep old key** available for existing proofs
5. **Monitor** for proof verification failures

---

## Security Considerations

### Public Keys

- ✅ Verification keys are **public** - safe to share
- ✅ No security risk if exposed
- ✅ Can be served from public CDN

### Integrity

- ✅ Verify key structure before use
- ✅ Check protocol matches (groth16)
- ✅ Validate curve (bn128)

### Availability

- ✅ Implement caching to reduce CDN load
- ✅ Have fallback (bundled key) if CDN fails
- ✅ Monitor CDN availability

---

## Testing

### Verify Key Structure

```bash
# Check key is valid JSON
cat tlsnotary.vkey.json | jq .

# Verify protocol
cat tlsnotary.vkey.json | jq '.protocol'  # Should be "groth16"

# Verify curve
cat tlsnotary.vkey.json | jq '.curve'  # Should be "bn128"
```

### Test Loading

```typescript
// Test CDN loading
const vkey = await fetch('https://cdn.anylayer.com/vkeys/tlsnotary.vkey.json')
  .then(r => r.json());
console.log('Protocol:', vkey.protocol);
console.log('Curve:', vkey.curve);

// Test verification
const snarkjs = require('snarkjs');
const verified = await snarkjs.groth16.verify(vkey, publicInputs, proof);
console.log('Verified:', verified);
```

---

## Current Implementation Status

### ✅ Completed

- Backend loads vkey from CDN (`functions/src/services/zkTLSService.js`)
- Environment variable support (`TLSNOTARY_VKEY_URL`)
- Fallback handling if CDN unavailable

### ⏱️ TODO

- [ ] Download verification key from TLSNotary releases
- [ ] Upload to CDN (`https://cdn.anylayer.com/vkeys/tlsnotary.vkey.json`)
- [ ] Add bundled fallback in extension
- [ ] Add caching in extension
- [ ] Test proof verification with real key

---

## Quick Start

### For Development (Now)

1. **Download key**:
   ```bash
   curl -L -o tlsnotary.vkey.json \
     https://github.com/tlsnotary/tlsn/releases/download/v0.1.0/tlsnotary.vkey.json
   ```

2. **Use CDN URL** (if available):
   ```bash
   export TLSNOTARY_VKEY_URL=https://cdn.anylayer.com/vkeys/tlsnotary.vkey.json
   ```

3. **Or bundle locally**:
   ```bash
   cp tlsnotary.vkey.json packages/zktls-extension/src/assets/vkeys/
   ```

### For Production (Future)

1. **Upload to CDN**:
   ```bash
   aws s3 cp tlsnotary.vkey.json s3://cdn.anylayer.com/vkeys/tlsnotary.vkey.json
   ```

2. **Set environment variable**:
   ```bash
   export TLSNOTARY_VKEY_URL=https://cdn.anylayer.com/vkeys/tlsnotary.vkey.json
   ```

3. **Deploy**:
   - Extension: Rebuild with env var
   - Backend: Set env var in Firebase Functions
   - Dashboard: Set `NEXT_PUBLIC_TLSNOTARY_VKEY_URL` in Vercel

---

## References

- TLSNotary Releases: https://github.com/tlsnotary/tlsn/releases
- snarkjs Documentation: https://github.com/iden3/snarkjs
- Groth16 Protocol: https://eprint.iacr.org/2016/260.pdf

